/*****************************************************************************

Copyright (c) 1996, 2020, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2.0, as published by the
Free Software Foundation.

This program is also distributed with certain software (including but not
limited to OpenSSL) that is licensed under separate terms, as designated in a
particular file or component or in included license documentation. The authors
of MySQL hereby grant you an additional permission to link the program and
your derivative works with the separately licensed software that they have
included with MySQL.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License, version 2.0,
for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA

*****************************************************************************/

/** @file include/trx0sys.ic
 Transaction system

 Created 3/26/1996 Heikki Tuuri
 *******************************************************/

#include "data0type.h"
#include "srv0srv.h"
#include "trx0trx.h"
#ifndef UNIV_HOTBACKUP
#include "mtr0log.h"

/* The typedef for rseg slot in the file copy */
typedef byte trx_sysf_rseg_t;

/* Rollback segment specification slot offsets */
/*-------------------------------------------------------------*/
#define TRX_SYS_RSEG_SPACE          \
  0 /* space where the segment      \
    header is placed; starting with \
    MySQL/InnoDB 5.1.7, this is     \
    UNIV_UNDEFINED if the slot is unused */
#define TRX_SYS_RSEG_PAGE_NO           \
  4 /*  page number where the segment  \
    header is placed; this is FIL_NULL \
    if the slot is unused */
/*-------------------------------------------------------------*/
/* Size of a rollback segment specification slot */
#define TRX_SYS_RSEG_SLOT_SIZE 8

/** Writes the value of max_trx_id to the file based trx system header. */
void trx_sys_flush_max_trx_id(void);

/** Checks if a page address is the trx sys header page.
@param[in]	page_id	page id
@return true if trx sys header page */
UNIV_INLINE
bool trx_sys_hdr_page(const page_id_t &page_id) {
  return (page_id.space() == TRX_SYS_SPACE &&
          page_id.page_no() == TRX_SYS_PAGE_NO);
}

/** Gets a pointer to the transaction system header and x-latches its page.
 @return pointer to system header, page x-latched. */
UNIV_INLINE
trx_sysf_t *trx_sysf_get(mtr_t *mtr) /*!< in: mtr */
{
  buf_block_t *block;
  trx_sysf_t *header;

  ut_ad(mtr);

  block = buf_page_get(page_id_t(TRX_SYS_SPACE, TRX_SYS_PAGE_NO),
                       univ_page_size, RW_X_LATCH, mtr);
  buf_block_dbg_add_level(block, SYNC_TRX_SYS_HEADER);

  header = TRX_SYS + buf_block_get_frame(block);

  return (header);
}

/** Gets the space of the nth rollback segment slot in the trx system
 file copy.
 @return space id */
UNIV_INLINE
space_id_t trx_sysf_rseg_get_space(
    trx_sysf_t *sys_header, /*!< in: trx sys header */
    ulint slot,             /*!< in: slot index == rseg id */
    mtr_t *mtr)             /*!< in: mtr */
{
  ut_ad(sys_header);
  ut_ad(slot < TRX_SYS_N_RSEGS);

  return (mtr_read_ulint(sys_header + TRX_SYS_RSEGS +
                             slot * TRX_SYS_RSEG_SLOT_SIZE + TRX_SYS_RSEG_SPACE,
                         MLOG_4BYTES, mtr));
}

/** Gets the page number of the nth rollback segment slot in the trx system
 header.
 @return page number, FIL_NULL if slot unused */
UNIV_INLINE
page_no_t trx_sysf_rseg_get_page_no(
    trx_sysf_t *sys_header, /*!< in: trx system header */
    ulint slot,             /*!< in: slot index == rseg id */
    mtr_t *mtr)             /*!< in: mtr */
{
  ut_ad(sys_header);
  ut_ad(slot < TRX_SYS_N_RSEGS);

  return (mtr_read_ulint(sys_header + TRX_SYS_RSEGS +
                             slot * TRX_SYS_RSEG_SLOT_SIZE +
                             TRX_SYS_RSEG_PAGE_NO,
                         MLOG_4BYTES, mtr));
}

/** Sets the space id of the nth rollback segment slot in the trx system
 file copy. */
UNIV_INLINE
void trx_sysf_rseg_set_space(
    trx_sysf_t *sys_header, /*!< in: trx sys file copy */
    ulint slot,             /*!< in: slot index == rseg id */
    space_id_t space,       /*!< in: space id */
    mtr_t *mtr)             /*!< in: mtr */
{
  ut_ad(sys_header);
  ut_ad(slot < TRX_SYS_N_RSEGS);

  mlog_write_ulint(sys_header + TRX_SYS_RSEGS + slot * TRX_SYS_RSEG_SLOT_SIZE +
                       TRX_SYS_RSEG_SPACE,
                   space, MLOG_4BYTES, mtr);
}

/** Sets the page number of the nth rollback segment slot in the trx system
 header. */
UNIV_INLINE
void trx_sysf_rseg_set_page_no(
    trx_sysf_t *sys_header, /*!< in: trx sys header */
    ulint slot,             /*!< in: slot index == rseg id */
    page_no_t page_no,      /*!< in: page number, FIL_NULL if the
                            slot is reset to unused */
    mtr_t *mtr)             /*!< in: mtr */
{
  ut_ad(sys_header);
  ut_ad(slot < TRX_SYS_N_RSEGS);

  mlog_write_ulint(sys_header + TRX_SYS_RSEGS + slot * TRX_SYS_RSEG_SLOT_SIZE +
                       TRX_SYS_RSEG_PAGE_NO,
                   page_no, MLOG_4BYTES, mtr);
}
#endif /* !UNIV_HOTBACKUP */

/** Writes a trx id to an index page. In case that the id size changes in
 some future version, this function should be used instead of
 mach_write_... */
UNIV_INLINE
void trx_write_trx_id(byte *ptr,   /*!< in: pointer to memory where written */
                      trx_id_t id) /*!< in: id */
{
  ut_ad(id > 0);
  mach_write_to_6(ptr, id);
}

#ifndef UNIV_HOTBACKUP
/** Reads a trx id from an index page. In case that the id size changes in
 some future version, this function should be used instead of
 mach_read_...
 @return id */
UNIV_INLINE
trx_id_t trx_read_trx_id(
    const byte *ptr) /*!< in: pointer to memory from where to read */
{
  return (mach_read_from_6(ptr));
}

#endif /* !UNIV_HOTBACKUP */
